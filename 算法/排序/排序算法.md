----
**题意描述：**

给定一个整数数组 nums，将该数组升序排列。

数据范围 `1 <= A.length <= 10000 ，-50000 <= A[i] <= 50000`

---

**示例：**

```c
输入：[5,2,3,1]
输出：[1,2,3,5]
```
```c
输入：[5,1,1,2,0,0]
输出：[0,0,1,1,2,5]
```

---

**解题思路：**
Alice: 排序的N种写法 ？？
Bob: 看来是的。
Alice: 桶排序 ？
Bob：桶就像是 Python 中的字典，或者 Java 中的 map， 记录每个元素出现的次数，然后按照 key 的大小遍历 字典，得到的就是从小到大有序的数组。只不过我们是直接用数组实现的，开了一个很大的数组记录每个元素出现的次数，如果是字典，内存消耗会小很多，但是字典好像没有办法保证按照 key 的大小遍历。
Alice: 不错不错。选择排序 ？
Bob: 选择排序就是 每次找出 第 k 小的元素放到 下标是 k-1 的位置上，外层循环可以是 n-1 次，因为第 n-1 小的元素归位后，整个数组就已经是有序的了。
Alice: 快速排序 ？   

----

**代码：**

Python 方法一： 库函数

```python
class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        nums.sort()
        return nums
```
JavaScript 方法一： 库函数 + 自定义比较函数

```javascript
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var sortArray = function(nums) {
    return nums.sort(sortNumber);     // 注意sort方法默认按照字符串排序 汗
};

var sortNumber =  function(a, b){
    return a - b;
}
```
Python 方法二： **桶排序**

```python
class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        bound = 50000 * 2 + 10
        buckets = [0 for x in range(bound)]     # 设定桶的大小
        for x in nums:
            buckets[x + 50000] += 1             # 数据存储到桶中
        ret = []
        for x in range(len(buckets)):           # 按顺序读取就是排序结果
            if buckets[x]:
                ret.extend([x - 50000] * buckets[x])
        return ret
```
JavaScript 方法二： **桶排序**， 数组太大，javascript  heap out of memory

```javascript
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var sortArray = function(nums) {

    // 初始化桶 
    let bound   = 50000 * 2 + 10;
    let buckets = new Array(bound);
    buckets.fill(0);

    // 存储进桶中
    for(let num of nums){
        buckets[num + 50000] ++;
    }

    //按顺序读取
    let ret = [];
    for(let i=0; i<buckets.length; ++i){
        while(buckets[i] > 0){
            ret.push(i - 50000);
        }
    }
    return ret;
    
};
```
JavaScript 方法三： **选择排序**，  每次找出第 k 小的元素放到合适的位置。


```javascript
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var sortArray = function(nums) {

    for(let i=0; i<nums.length; ++i){
        let minIndex = i;
        // 每次找出第 k 小的元素放到合适的位置
        for(let j=i+1; j<nums.length; ++j){
            if(nums[j] < nums[minIndex]){
                minIndex = j;
            }
        }
        swap(nums, minIndex, i);
    }
    return nums
};

var swap = function(nums, indexa, indexb){
    let tmp = nums[indexa];
    nums[indexa] = nums[indexb];
    nums[indexb] = tmp;
    return ;
}
```
JavaScript 方法四： **冒泡排序**

```javascript
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var sortArray = function(nums) {
    for(let i=0; i<nums.length-1; ++i){            // 冒泡排序仅仅需要 n-1 趟
        for(let j=0; j<nums.length-1; ++j){        // 每趟冒泡一个最大值到数组末尾
            if(nums[j] > nums[j+1]){
                swap(nums, j, j+1);
            }
        }
    }
    return nums;
};

var swap = function(nums, indexa, indexb){
    let tmp = nums[indexa];
    nums[indexa] = nums[indexb];
    nums[indexb] = tmp;
    return ; 
}
```
JavaScript 方法四 **冒泡排序**，优化循环，及时跳出循环。

```javascript
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var sortArray = function(nums) {
    
    for(let i=0; i<nums.length-1; ++i){
        let order = true;                       // 记录是否已经有序
        for(let j=0; j<nums.length-1-i; ++j){   // 只有前面的nums.length-1-i 个元素是无序的
            if(nums[j] > nums[j+1]){
                swap(nums, j, j+1);
                order = false;
            }
        }
        if(order == true){
            break;
        }
    }
    return nums;
};

var swap = function(nums, indexa, indexb){
    let tmp = nums[indexa];
    nums[indexa] = nums[indexb];
    nums[indexb] = tmp;
    return;
}
```

JavaScript 方法五： **插入排序**，通过交换相邻元素实现插入

```javascript
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var sortArray = function(nums) {
    for(let i=1; i<nums.length; ++i){       // 每次插入一个元素到 前 i 个元素中
        for(let j=i; j>=1; --j){            // 前 i 个元素都是有序的
            if(nums[j] < nums[j-1]){        // 通过连续交换相邻元素插入到合适位置
                swap(nums, j, j-1);
            }else{
                break;
            }
        }
    }
    return nums;
};

var swap = function(nums, indexa, indexb){
    let tmp = nums[indexa];
    nums[indexa] = nums[indexb];
    nums[indexb] = tmp;
    return;
}
```
JavaScript 方法五， **插入排序**，通过移动数组，实现插入。

```javascript
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var sortArray = function(nums) {
    for(let i=1; i<nums.length; ++i){
        let tmp = nums[i];
        let index = 0;
        for(let j=i-1; j>=0; --j){
            if(nums[j] > tmp){
                nums[j+1] = nums[j];      // 移动数组
            }else{ 
                index = j + 1;            // 最后要插入的位置
                break;
            }
        }
        nums[index] = tmp;
    }
    return nums;
};
```
JavaScript 方法六，**希尔排序**，其中使用的插入排序方式为 交换相邻组内元素。

```javascript
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var sortArray = function(nums) {
    //shellsort
    for(let gap=parseInt(nums.length/2); gap>=1; gap=parseInt(gap/2)){ // 使用gap实现分组
        for(let i=gap; i<nums.length; ++i){  // 跨组插入排序，和分组别插入排序效果一样
            for(let j=i; j>=gap; j-=gap){    // 在每个组内插入排序
                if(nums[j] < nums[j-gap]){
                    swap(nums, j, j-gap);
                }else{
                    break;
                }
            }
        }
    }
    return nums;
};

var swap = function(num, indexa, indexb){
    let tmp = num[indexa];
    num[indexa] = num[indexb];
    num[indexb] = tmp;
    return;
}
```
JavaScript 方法七，归并排序，递归 + 合并两个有序数组

```javascript
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var sortArray = function(nums) {
    let tmp = new Array(nums.length);        // 从始至终使用的O(n)的数组
    mergeSort(nums, 0, nums.length-1, tmp);  // 归并排序
    return nums;
};

var mergeSort = function(nums, left, right, tmp){
    if(left >= right){
        return;
    }
    let middle = parseInt((left + right) / 2);
    mergeSort(nums, left, middle, tmp); 
    mergeSort(nums, middle + 1, right, tmp);
    merge(nums, left, right, middle, tmp);     
    // 合并从 left 到 middle 以及 从 middle + 1 到 right 的两个有序数组
}

var merge = function(nums, left, right, middle, tmp){
    // 合并 nums 中[left, middle], [middle+1, right] 到 tmp[1, K]
    let i = left;
    let j = middle + 1;
    let t = 0;
    while(i <= middle && j <= right){
        if(nums[i] < nums[j]){
            tmp[t++] = nums[i++];
        }else{
            tmp[t++] = nums[j++];
        }
    }
    while(i<=middle){
        tmp[t++] = nums[i++];
    }
    while(j<=right){
        tmp[t++] = nums[j++];
    }
    // 将合并后的有序数组放置到 nums 中指定的位置
    t = 0;
    let start = left;
    while(start <= right){
        nums[start++] = tmp[t++];
    }
    return;
}
```
JavaScript 方法八， 快速排序，通过“反复横跳”实现 partition

```javascript
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var sortArray = function(nums) {
    quickSort(nums, 0, nums.length-1);
    return nums;
};

var quickSort = function(nums, left, right){

    if(left >= right){
        return;
    }

    let l = left;
    let r = right;
    let anchor = nums[l];

    while(l < r){

        // 从后往前找到一个 小于anchor 的元素 放到anchor 左侧
        while(l < r && nums[r] >= anchor){
            r--;
        }
        nums[l] = nums[r];

        // 从前往后找到一个 大于等于 anchor 的元素 放到 anchor 右侧
        while(l < r && nums[l] < anchor){
            l ++;
        }
        nums[r] = nums[l];
    }
    let anchorIndex = l;
    nums[anchorIndex] = anchor;

    quickSort(nums, left, anchorIndex-1);
    quickSort(nums, anchorIndex+1, right);
}
```

----

**易错点：**

- 一些测试用例
```c
[5,2,3,1]
[5,1,1,2,0,0]
[1]
[50000,-50000]
```
- 答案：
```c
[1,2,3,5]
[0,0,1,1,2,5]
[1]
[-50000,50000]
```

----

**总结：**
- [JavaScript 数组排序](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
- [JavaScript sort()](https://www.w3school.com.cn/js/jsref_sort.asp)
- [排序](https://github.com/CavsZhouyou/Front-End-Interview-Notebook/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95.md#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F)

---